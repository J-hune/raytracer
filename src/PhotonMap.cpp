#include "../include/PhotonMap.h"
#include "../include/Intersection.h"
#include "../include/Lighting.h"
#include <cmath>
#include <thread>
#include <GL/gl.h>

/******************************************************************************************************************/
/******************************************** PHOTON EMISSION FUNCTIONS *******************************************/
/******************************************************************************************************************/


void PhotonMap::emitPhotons(
    const std::vector<Light> &lights, const std::vector<Sphere> &spheres, const std::vector<Square> &squares,
    const std::vector<Mesh> &meshes, const MeshKDTree &kdTree, const int photons)
{
    if (photons <= 0) {
        throw std::invalid_argument("Number of photons must be greater than zero.");
    }

    if (lights.empty()) {
        throw std::invalid_argument("No lights in the scene.");
    }

    std::vector<Photon> globalPhotons;
    std::vector<Photon> photonsToEmit;
    photonsToEmit.reserve(photons * 2);

    std::mutex photonMutex;  // Mutex for shared data

    // Split the photon emission task among multiple threads
    const int numThreads = static_cast<int>(std::thread::hardware_concurrency());
    const int photonsPerThread = photons / numThreads;

    // Launch threads
    std::vector<std::thread> threads;
    for (int i = 0; i < numThreads; ++i) {
        threads.emplace_back(
            &PhotonMap::emitPhotonsForThread, this, photonsPerThread, std::cref(lights), std::cref(spheres), std::cref(squares),
            std::cref(meshes), std::ref(kdTree), std::ref(photonMutex), std::ref(globalPhotons), std::ref(photonsToEmit));
    }

    // Wait for all threads to complete
    for (auto &thread : threads) {
        thread.join();
    }

    globalPhotonTree = PhotonKDTree(globalPhotons);
}

void PhotonMap::emitPhotonsForThread(const int photonCount, const std::vector<Light> &lights, const std::vector<Sphere> &spheres,
    const std::vector<Square> &squares, const std::vector<Mesh> &meshes, const MeshKDTree &kdTree,
    std::mutex &photonMutex, std::vector<Photon> &globalPhotons, std::vector<Photon> &photonsToEmit)
{
    // Initialize a random number generator for this thread
    std::mt19937 threadRng(std::random_device{}());
    std::uniform_real_distribution randDistrib(0.0f, 1.0f);

    // Local vectors to store photons generated by this thread, to avoid data races
    std::vector<Photon> threadGlobalPhotons;
    std::vector<Photon> threadInitialPhotons;
    std::vector<Photon> threadPhotonsToEmit;
    threadPhotonsToEmit.reserve(photonCount * 2);

    // Emit photons until the desired count is reached
    int emittedPhotons = 0;
    while (threadGlobalPhotons.size() < static_cast<size_t>(photonCount)) {
        // Create an initial photon using the random number generator
        Photon photon = createInitialPhoton(lights, threadRng);
        threadPhotonsToEmit.emplace_back(photon);
        threadInitialPhotons.emplace_back(photon);
        emittedPhotons++;

        // Track whether the photon is absorbed
        bool absorbed = false;

        // Process photon interactions with the scene, while it is not absorbed (with max bounce limit)
        for (int j = 0; j < 500 && !absorbed; j++) {
            Ray ray(photon.position, photon.direction);

            // Compute intersection of the ray with the scene and extract intersection data
            RaySceneIntersection intersection = Intersection::computeIntersection(ray, spheres, squares, meshes, kdTree, 0.0f);
            if (!intersection.intersectionExists) break;
            photon.position = intersection.intersection;

            // Process the photon based on the material at the intersection point
            if (intersection.material.type == Material_Glass) {
                processGlassPhoton(photon, intersection.normal, intersection.material, threadPhotonsToEmit);
            } else if (intersection.material.type == Material_Mirror) {
                processMirrorPhoton(photon, intersection.normal, intersection.material);
            } else if (intersection.material.type == Material_Diffuse_Blinn_Phong) {
                float Pr, Pd, Ps;
                computeReflectionProbabilities(intersection.material, Pr, Pd, Ps);
                const float xi = randDistrib(threadRng);
                threadGlobalPhotons.emplace_back(photon);

                // Russian roulette decision
                if (xi < Pd) { // Diffuse reflection ξ ∈[0, Pd]
                    photon.direction = randomDirection(threadRng, intersection.normal);
                    photon.color = Vec3::compProduct(photon.color, intersection.material.diffuse_material) / Pd;

                } else if (xi < Pd + Ps) { // Specular reflection ξ ∈]Pd, Ps + Pd]
                    photon.direction = Lighting::computeReflectedDirection(photon.direction, intersection.normal).normalize();
                    photon.color = Vec3::compProduct(photon.color, intersection.material.specular_material) / Pr;

                } else { // Absorption ξ ∈]Ps + Pd, 1]
                    absorbed = true;
                }
            }
        }
    }

    // Normalize the color of the emitted photons
    for (Photon &photon : threadGlobalPhotons) {
        photon.debugColor = photon.color;
        photon.color /= static_cast<float>(emittedPhotons);
    }

    // Lock mutex to safely add thread-specific photons to shared vectors
    std::lock_guard lock(photonMutex);
    globalPhotons.insert(globalPhotons.end(), threadGlobalPhotons.begin(), threadGlobalPhotons.end());
    photonsToEmit.insert(photonsToEmit.end(), threadPhotonsToEmit.begin(), threadPhotonsToEmit.end());
    initialPhotons.insert(initialPhotons.end(), threadInitialPhotons.begin(), threadInitialPhotons.end());
}

Photon PhotonMap::createInitialPhoton(const std::vector<Light>& lights, std::mt19937& rng) {
    Photon photon;

    // Pick a random light source to emit the photon
    std::uniform_int_distribution lightDist(0, static_cast<int>(lights.size()) - 1);
    const Light& light = lights[lightDist(rng)];

    photon.position = light.position;
    photon.color = light.material;
    photon.direction = randomDirection(rng);
    return photon;
}

void PhotonMap::computeReflectionProbabilities(const Material& material, float &Pr, float &Pd, float &Ps) {
    // Compute the probabilities of reflection, diffuse reflection, and specular reflection
    const float maxReflection = std::max({ // Pr = max(d + s)
        material.diffuse_material[0] + material.specular_material[0],
        material.diffuse_material[1] + material.specular_material[1],
        material.diffuse_material[2] + material.specular_material[2]
    });
    Pr = maxReflection;
    const float totalReflection = // dr + dg + db + sr + sg + sb
        material.diffuse_material[0] + material.diffuse_material[1] + material.diffuse_material[2] +
        material.specular_material[0] + material.specular_material[1] + material.specular_material[2];

    Pd = (material.diffuse_material[0] + material.diffuse_material[1] + material.diffuse_material[2]) / totalReflection * Pr;
    Ps = Pr - Pd;
}

void PhotonMap::processGlassPhoton(Photon& photon, const Vec3& normal, const Material& material, std::vector<Photon>& photons) {
    const float fresnelEffect = Lighting::computeFresnelEffect(photon.direction, normal, material.index_medium);

    // Two effects: one part goes into reflection, the other into refraction
    // The percentage of reflection is calculated by the Fresnel effect
    const Vec3 refractedDirection = Lighting::computeRefractedDirection(photon.direction, normal, material.index_medium).normalize();
    const Vec3 reflectedDirection = Lighting::computeReflectedDirection(photon.direction, normal).normalize();

    // The color of the reflected photon takes into account the color of the object and the percentage of reflection
    Photon reflectedPhoton = photon;
    reflectedPhoton.direction = reflectedDirection;
    reflectedPhoton.color = fresnelEffect * Vec3::compProduct(photon.color, material.specular_material);
    photons.emplace_back(reflectedPhoton);

    // Add object color to the photon color (with transparency)
    photon.direction = refractedDirection;
    photon.color = (1 - fresnelEffect) * (material.transparency * photon.color + (1 - material.transparency) * material.specular_material);
}

void PhotonMap::processMirrorPhoton(Photon& photon, const Vec3& normal, const Material& material) {
    // Change the direction of the photon to make it bounce, keep the color at 90% to simulate reflection
    photon.direction = Lighting::computeReflectedDirection(photon.direction, normal).normalize();
    photon.color = 0.9f * Vec3::compProduct(photon.color, material.specular_material);
}


/******************************************************************************************************************/
/******************************************* PHOTON RENDERING FUNCTIONS *******************************************/
/******************************************************************************************************************/

Vec3 PhotonMap::computeCaustics(const Vec3 &position, const Material &material) const {
    // Find nearby photons in the global photon map
    constexpr float globalDistance = 0.5f;
    const std::vector<Photon> nearbyGlobalPhotons = globalPhotonTree.findNearestNeighbors(position, globalDistance);

    Vec3 illumination(0.0f);
    if (nearbyGlobalPhotons.empty()) return illumination;

    // Accumulate the color of the nearby photons
    for (const Photon &photon : nearbyGlobalPhotons) {
        illumination += Vec3::compProduct(photon.color, material.diffuse_material);
    }

    return illumination;
}

Vec3 PhotonMap::randomDirection(std::mt19937 &rng, const Vec3 &normal) {
    std::uniform_real_distribution<float> dist(0.0f, 1.0f);
    const float theta = 2.0f * M_PIf * dist(rng); // Azimuthal angle
    const float phi = std::acos(2.0f * dist(rng) - 1.0f); // Polar angle for full sphere
    const float x = std::sin(phi) * std::cos(theta);
    const float y = std::cos(phi);
    const float z = std::sin(phi) * std::sin(theta);

    Vec3 direction(x, y, z);

    // Ensure the direction is within the hemisphere defined by the normal
    if (normal != Vec3(0.0f) && Vec3::dot(direction, normal) < 0.0f) {
        direction = -direction;
    }

    return direction;
}

Vec3 PhotonMap::randomDirectionTowardsObjects(std::mt19937 &rng, const std::vector<Sphere>& spheres, const std::vector<Mesh>& meshes) {
    std::uniform_real_distribution<float> dist(0.0f, 1.0f);

    // Select a random object type
    const int totalObjects = static_cast<int>(spheres.size() + meshes.size());
    std::uniform_int_distribution<int> objectDist(0, totalObjects - 1);
    const int objectIndex = objectDist(rng);

    Vec3 target;

    if (objectIndex < static_cast<int>(spheres.size())) {
        // Select a random point on the sphere
        const Sphere& sphere = spheres[objectIndex];
        const float theta = dist(rng) * 2.0f * M_PIf;
        const float phi = std::acos(2.0f * dist(rng) - 1.0f);
        const float x = sphere.m_radius * std::sin(phi) * std::cos(theta);
        const float y = sphere.m_radius * std::sin(phi) * std::sin(theta);
        const float z = sphere.m_radius * std::cos(phi);
        target = sphere.m_center + Vec3(x, y, z);
    } else {
        // Select a random point on the mesh
        const Mesh& mesh = meshes[objectIndex - spheres.size()];
        target = mesh.getRandomPointOnSurface(rng).position;
    }

    // Generate a direction vector from the origin to the target point
    Vec3 direction = target - Vec3(0.0f, 0.0f, 0.0f);
    return direction;
}


/******************************************************************************************************************/
/********************************************** DEBUG DRAW FUNCTIONS **********************************************/
/******************************************************************************************************************/

void PhotonMap::debugDrawPhotons() {
    glDisable(GL_LIGHTING);
    glEnable(GL_COLOR_MATERIAL);

    // Only build the global photon vector once
    if (globalPhotons.empty()) globalPhotons = globalPhotonTree.toVector();

    // Debug: Draw the photons
    for (const Photon &photon : globalPhotons) {
        Vec3 color = photon.debugColor;
        glColor3f(color[0], color[1], color[2]);
        glBegin(GL_POINTS);
        glVertex3f(photon.position[0], photon.position[1], photon.position[2]);
        glEnd();
    }

    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
}

void PhotonMap::debugDrawLightPaths() const {
    glDisable(GL_LIGHTING);
    glEnable(GL_COLOR_MATERIAL);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    for (const Photon &photon : initialPhotons) {
        glColor4f(initialPhotons[0].color[0], initialPhotons[0].color[1], initialPhotons[0].color[2], 0.2f);
        glBegin(GL_LINES);
        glVertex3f(photon.position[0], photon.position[1], photon.position[2]);
        glVertex3f(photon.direction[0] + photon.position[0], photon.direction[1] + photon.position[1], photon.direction[2] + photon.position[2]);
        glEnd();
    }

    glDisable(GL_BLEND);
    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
}