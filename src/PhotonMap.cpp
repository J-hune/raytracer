#include "../include/PhotonMap.h"
#include "../include/Intersection.h"
#include "../include/Lighting.h"
#include <cmath>
#include <thread>
#include <GL/gl.h>

/******************************************************************************************************************/
/******************************************** PHOTON EMISSION FUNCTIONS *******************************************/
/******************************************************************************************************************/


void PhotonMap::emitPhotons(
    const std::vector<Light> &lights, const std::vector<Sphere> &spheres, const std::vector<Square> &squares,
    const std::vector<Mesh> &meshes, const MeshKDTree &kdTree, const int photons)
{
    if (photons <= 0) {
        throw std::invalid_argument("Number of photons must be greater than zero.");
    }

    if (lights.empty()) {
        throw std::invalid_argument("No lights in the scene.");
    }

    std::vector<Photon> mirrorPhotons;
    std::vector<Photon> glassPhotons;
    std::vector<Photon> photonsToEmit;
    photonsToEmit.reserve(photons * 2);

    std::mutex photonMutex;  // Mutex for shared data

    // Split the photon emission task among multiple threads
    const int numThreads = static_cast<int>(std::thread::hardware_concurrency());
    const int photonsPerThread = photons / numThreads;

    // Launch threads
    std::vector<std::thread> threads;
    for (int i = 0; i < numThreads; ++i) {
        threads.emplace_back(
            &PhotonMap::emitPhotonsForThread, this, photonsPerThread, std::cref(lights), std::cref(spheres), std::cref(squares),
            std::cref(meshes), std::ref(kdTree), std::ref(photonMutex), std::ref(mirrorPhotons), std::ref(glassPhotons), std::ref(photonsToEmit));
    }

    // Wait for all threads to complete
    for (auto &thread : threads) {
        thread.join();
    }

    mirrorPhotonTree = PhotonKDTree(mirrorPhotons);
    glassPhotonTree = PhotonKDTree(glassPhotons);
}

void PhotonMap::emitPhotonsForThread(
    int photonCount, const std::vector<Light> &lights, const std::vector<Sphere> &spheres,
    const std::vector<Square> &squares, const std::vector<Mesh> &meshes, const MeshKDTree &kdTree,
    std::mutex &photonMutex, std::vector<Photon> &mirrorPhotons, std::vector<Photon> &glassPhotons, std::vector<Photon> &photonsToEmit)
{
    // Initialize a random number generator for this thread
    std::mt19937 threadRng(std::random_device{}());

    // Local vectors to store photons generated by this thread, to avoid data races
    std::vector<Photon> threadMirrorPhotons;
    std::vector<Photon> threadGlassPhotons;
    std::vector<Photon> threadInitialPhotons;
    std::vector<Photon> threadPhotonsToEmit;
    threadPhotonsToEmit.reserve(photonCount * 2);

    // Emit the specified number of photons for this thread
    for (int i = 0; i < photonCount; ++i) {
        // Create an initial photon using the random number generator
        Photon photon = createInitialPhoton(lights, threadRng, spheres, squares, meshes);

        // Store the initial photon in the local vector
        threadPhotonsToEmit.emplace_back(photon);
        threadInitialPhotons.emplace_back(photon);

        // Track whether the photon is absorbed
        bool absorbed = false;

        // Process photon interactions with the scene, up to 10 interactions per photon
        for (int j = 0; j < 10 && !absorbed; j++) {
            Ray ray(photon.position, photon.direction);

            // Compute intersection of the ray with the scene and extract intersection data
            RaySceneIntersection intersection = Intersection::computeIntersection(ray, spheres, squares, meshes, kdTree, 0.0f);
            if (!intersection.intersectionExists) break;

            // Calculate distance traveled by photon and attenuation
            const float distanceTraveled = (intersection.intersection - photon.position).length();
            photon.position = intersection.intersection;
            float attenuationFactor = 1.0f;

            // Apply attenuation based on material type
            if (intersection.material.type == Material_Diffuse_Blinn_Phong || intersection.material.type == Material_Mirror) {
                constexpr float absorptionCoefficientAir = 0.02f;
                attenuationFactor = std::exp(-distanceTraveled * absorptionCoefficientAir);
            } else if (intersection.material.type == Material_Glass) {
                constexpr float absorptionCoefficientGlass = 0.1f;
                attenuationFactor = std::exp(-distanceTraveled * absorptionCoefficientGlass);
            }

            photon.color *= attenuationFactor; // Adjust photon color by attenuation

            // Handle photon behavior based on material type
            switch (intersection.material.type) {
                case Material_Diffuse_Blinn_Phong:
                    if (photon.materialType == Material_Glass) {
                        threadGlassPhotons.emplace_back(photon);
                        absorbed = true;
                    } else if (photon.materialType == Material_Mirror) {
                        threadMirrorPhotons.emplace_back(photon);
                        absorbed = true;
                    }
                    break;
                case Material_Glass:
                    processGlassPhoton(photon, intersection.normal, intersection.material, threadPhotonsToEmit);
                    break;
                case Material_Mirror:
                    processMirrorPhoton(photon, intersection.normal, intersection.material);
                    break;
            }
        }
    }

    // Lock mutex to safely add thread-specific photons to shared vectors
    std::lock_guard<std::mutex> lock(photonMutex);
    mirrorPhotons.insert(mirrorPhotons.end(), threadMirrorPhotons.begin(), threadMirrorPhotons.end());
    glassPhotons.insert(glassPhotons.end(), threadGlassPhotons.begin(), threadGlassPhotons.end());
    photonsToEmit.insert(photonsToEmit.end(), threadPhotonsToEmit.begin(), threadPhotonsToEmit.end());
    initialPhotons.insert(initialPhotons.end(), threadInitialPhotons.begin(), threadInitialPhotons.end());
}

Photon PhotonMap::createInitialPhoton(const std::vector<Light>& lights, std::mt19937& rng, const std::vector<Sphere>& spheres, const std::vector<Square>& squares, const std::vector<Mesh>& meshes) {
    Photon photon;
    std::uniform_int_distribution<int> lightDist(0, static_cast<int>(lights.size()) - 1);
    const Light& light = lights[lightDist(rng)];

    photon.position = light.position;
    photon.color = light.material;
    photon.direction = randomDirection(rng, spheres, squares, meshes);
    photon.materialType = Material_Diffuse_Blinn_Phong;
    return photon;
}

void PhotonMap::processGlassPhoton(Photon& photon, const Vec3& normal, const Material& material, std::vector<Photon>& photons) {
    const float fresnelEffect = Lighting::computeFresnelEffect(photon.direction, normal, material.index_medium);

    // Two effects: one part goes into reflection, the other into refraction
    // The percentage of reflection is calculated by the Fresnel effect
    const Vec3 refractedDirection = Lighting::computeRefractedDirection(photon.direction, normal, material.index_medium).normalize();
    const Vec3 reflectedDirection = Lighting::computeReflectedDirection(photon.direction, normal).normalize();

    // The color of the reflected photon takes into account the color of the object and the percentage of reflection
    Photon reflectedPhoton = photon;
    reflectedPhoton.direction = reflectedDirection;
    reflectedPhoton.color = fresnelEffect * Vec3::compProduct(photon.color, material.specular_material);
    reflectedPhoton.materialType = material.type;
    photons.emplace_back(reflectedPhoton);

    // Add object color to the photon color (with transparency)
    photon.direction = refractedDirection;
    photon.color = (1 - fresnelEffect) * (material.transparency * photon.color + (1 - material.transparency) * material.specular_material);
    photon.materialType = material.type;
}

void PhotonMap::processMirrorPhoton(Photon& photon, const Vec3& normal, const Material& material) {
    // Change the direction of the photon to make it bounce, keep the color at 90% to simulate reflection
    photon.direction = Lighting::computeReflectedDirection(photon.direction, normal).normalize();
    photon.color = 0.9f * Vec3::compProduct(photon.color, material.specular_material);
    photon.materialType = material.type;
}


/******************************************************************************************************************/
/******************************************* PHOTON RENDERING FUNCTIONS *******************************************/
/******************************************************************************************************************/

Vec3 PhotonMap::computeCaustics(const Vec3 &position, const Material &material) const {
    // Define maximum search distances for mirror and glass photons
    constexpr float maxMirrorDistance = 1.0f;
    constexpr float maxGlassDistance = 0.3f;

    // Initialize temporary search radii for expanding searches if not enough photons are found
    float maxMirrorDistanceTemp = 0.05f;
    float maxGlassDistanceTemp = 0.05f;

    // Vectors to store nearby photons
    std::vector<Photon> nearbyMirrorPhotons;
    std::vector<Photon> nearbyGlassPhotons;

    // Gradually increase the search radius until we find at least 5 nearby mirror photons or reach the max distance
    while (nearbyMirrorPhotons.empty() && maxMirrorDistanceTemp < maxMirrorDistance) {
        nearbyMirrorPhotons = mirrorPhotonTree.findNearestNeighbors(position, maxMirrorDistance);
        maxMirrorDistanceTemp *= 1.05f;
    }

    // Gradually increase the search radius until we find at least 5 nearby glass photons or reach the max distance
    while (nearbyGlassPhotons.empty() && maxGlassDistanceTemp < maxGlassDistance) {
        nearbyGlassPhotons = glassPhotonTree.findNearestNeighbors(position, maxGlassDistance);
        maxGlassDistanceTemp *= 1.05f;
    }

    Vec3 illumination(0.0f);
    if (nearbyMirrorPhotons.empty() && nearbyGlassPhotons.empty()) return illumination;


    // Accumulate illumination from mirror photons by combining their color with the material's diffuse properties
    for (const Photon &photon : nearbyMirrorPhotons) {
        illumination += Vec3::compProduct(photon.color, material.diffuse_material);
    }

    // Accumulate illumination from glass photons similarly
    for (const Photon &photon : nearbyGlassPhotons) {
        illumination += Vec3::compProduct(photon.color, material.diffuse_material);
    }

    return illumination;
}

Vec3 PhotonMap::randomDirection(std::mt19937 &rng, const std::vector<Sphere>& spheres, const std::vector<Square>& squares, const std::vector<Mesh>& meshes) {
    std::uniform_real_distribution<float> dist(0.0f, 1.0f);

    // Select a random object type
    const int totalObjects = static_cast<int>(spheres.size() + meshes.size());
    std::uniform_int_distribution<int> objectDist(0, totalObjects - 1);
    const int objectIndex = objectDist(rng);

    Vec3 target;

    if (objectIndex < static_cast<int>(spheres.size())) {
        // Select a random point on the sphere
        const Sphere& sphere = spheres[objectIndex];
        const float theta = dist(rng) * 2.0f * M_PIf;
        const float phi = std::acos(2.0f * dist(rng) - 1.0f);
        const float x = sphere.m_radius * std::sin(phi) * std::cos(theta);
        const float y = sphere.m_radius * std::sin(phi) * std::sin(theta);
        const float z = sphere.m_radius * std::cos(phi);
        target = sphere.m_center + Vec3(x, y, z);
    } else {
        // Select a random point on the mesh
        const Mesh& mesh = meshes[objectIndex - spheres.size()];
        target = mesh.getRandomPointOnSurface(rng).position;
    }

    // Generate a direction vector from the origin to the target point
    Vec3 direction = (target - Vec3(0.0f, 0.0f, 0.0f));
    return direction;
}


/******************************************************************************************************************/
/********************************************** DEBUG DRAW FUNCTIONS **********************************************/
/******************************************************************************************************************/

void PhotonMap::debugDrawPhotons() const {
    glDisable(GL_LIGHTING);
    glEnable(GL_COLOR_MATERIAL);

    // Debug: Draw the photons
    std::vector<Photon> photons = mirrorPhotonTree.toVector();
    for (const auto &[position, direction, color, materialType] : photons) {
        glColor3f(color[0], color[1], color[2]);
        glBegin(GL_POINTS);
        glVertex3f(position[0], position[1], position[2]);
        glEnd();
    }

    std::vector<Photon> glassPhotons = glassPhotonTree.toVector();
    for (const auto &[position, direction, color, materialType] : glassPhotons) {
        glColor3f(0.0f, 0.3f, 1.0f);
        glBegin(GL_POINTS);
        glVertex3f(position[0], position[1], position[2]);
        glEnd();
    }

    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
}

void PhotonMap::debugDrawLightPaths() const {
    glDisable(GL_LIGHTING);
    glEnable(GL_COLOR_MATERIAL);

    for (auto [position, direction, color, materialType] : initialPhotons) {
        glColor3f(0.5f, 0.5f, 0.5f);
        glBegin(GL_LINES);
        glVertex3f(position[0], position[1], position[2]);

        glVertex3f(
            direction[0],
            direction[1],
            direction[2]
        );
        glEnd();
    }

    glDisable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
}